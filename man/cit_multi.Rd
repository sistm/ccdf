% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cit_multi.R
\name{cit_multi}
\alias{cit_multi}
\title{Multiple conditional independence testing}
\usage{
cit_multi(
  M,
  X,
  Z = NULL,
  test = c("asymptotic", "permutation"),
  n_perm = 100,
  n_perm_adaptive = c(n_perm, n_perm, n_perm * 3, n_perm * 5),
  thresholds = c(0.1, 0.05, 0.01),
  parallel = interactive(),
  n_cpus = detectCores() - 1,
  adaptive = TRUE,
  space_y = TRUE,
  number_y = 10
)
}
\arguments{
\item{M}{a \code{data.frame} or a \code{matrix} of size \code{n x r} 
containing the different Y variables to test for conditional independence 
with \code{X} adjusted on \code{Z}}

\item{X}{a data frame of size \code{n x p} of numeric or factor vector(s) 
containing the variable(s) to be tested for conditional independence 
against \code{X} adjusted on \code{Z}. Multiple variables (\code{p>1}) 
are only supported by the asymptotic test.}

\item{Z}{a data frame of size \code{n x q} of numeric or factor vector(s) 
containing the covariate(s) to condition the independence 
test upon. Multiple covariates (\code{q>1}) are only supported by the 
asymptotic test.}

\item{test}{a character string indicating whether the \code{'asymptotic'} or 
the \code{'permutation'} test is computed.
Default is \code{'asymptotic'}.}

\item{n_perm}{the number of permutations. Default is \code{100}. Only used if
\code{test == 'permutation'}.}

\item{n_perm_adaptive}{a vector of the increasing numbers of 
adaptive permutations when \code{adaptive} is \code{TRUE}. 
\code{length(n_perm_adaptive)} should be equal to \code{length(thresholds)+1}. 
Default is \code{c(100, 150, 250, 500)}.}

\item{thresholds}{a vector of the decreasing thresholds to compute
adaptive permutations when \code{adaptive} is \code{TRUE}. 
\code{length(thresholds)} should be equal to \code{length(n_perm_adaptive)-1}.
Default is \code{c(0.1, 0.05, 0.01)}.}

\item{parallel}{a logical flag indicating whether parallel computation
should be enabled. Default is \code{TRUE} if \code{interactive()} is 
\code{TRUE}, else is \code{FALSE}.}

\item{n_cpus}{an integer indicating the number of cores to be used for the 
computations. Default is \code{parallel::detectCores() - 1}. If 
\code{n_cpus = 1}, then sequential computations are used without any 
parallelization.}

\item{adaptive}{a logical flag indicating whether adaptive permutations
should be performed. Default is \code{TRUE}. Only used if
\code{test == 'permutation'}.}

\item{space_y}{a logical flag indicating whether the y thresholds are spaced out. 
When \code{space_y} is \code{TRUE}, a regular sequence between the minimum and 
the maximum of the observations is used. If \code{FALSE}, each unique 
observed expression value is used as a distinct threshold. Default is \code{TRUE}.}

\item{number_y}{an integer value indicating the number of y thresholds (and therefore
the number of regressions) to perform the test. Default is 10.}
}
\value{
A list with the following elements:\itemize{
  \item \code{which_test}: a character string carrying forward the value of
  the '\code{which_test}' argument indicating which test was performed (either
  'asymptotic' or 'permutation').
  \item \code{n_perm}: an integer carrying forward the value of the
  '\code{n_perm}' argument or '\code{n_perm_adaptive}' indicating the number of permutations performed
  (\code{NA} if asymptotic test was performed).
  \item \code{pval}: computed p-values. A data frame with one raw for
  each gene, and with 2 columns: the first one '\code{raw_pval}' contains
  the raw p-values, the second one '\code{adj_pval}' contains the FDR adjusted p-values
  using Benjamini-Hochberg correction.
}
}
\description{
Multiple conditional independence testing
}
\examples{


Z <- as.factor(rbinom(n=100, size = 1, prob = 0.5))
X <- as.numeric(Z)-1  + rnorm(n=100, sd=1)
r <- 1000
Y <- replicate(r, as.numeric(Z)-1)
Y <- (Y==1)*rnorm(n = 100*r,0,1) + (Y==0)*rnorm(n = 100*r,0.5,1)
res_asymp_unadj <- cit_multi(M = data.frame(Y=Y), 
                X = data.frame(X1=X1, X2=X2),
                test="asymptotic", parallel=FALSE)
mean(res_asymp_unadj$pvals$raw_pval<0.05)
hist(res_asymp_unadj$pvals$raw_pval)

set.seed(123)
n <- 100
r <- 200
Z1 <- rbinom(n, size=1, prob=0.5)
Z2 <- rnorm(n)#rbinom(n, size=1, prob=0.5) + rnorm(n, sd=0.05)
X1 <- Z2 + rnorm(n, sd=0.2)
X2 <- rnorm(n)
cor(X1, Z2)
Y <- replicate(r, Z2) + rnorm(n*r, 0, 0.5)
Y <- replicate(r, as.numeric(Z1)-1)
YY <- (Y==1)*rnorm(n = 100*r,0,1) + (Y==0)*rnorm(n = 100*r,0.5,1)
range(cor(Y, Z2))
range(cor(Y, X2))
res_asymp_unadj <- cit_multi(M = data.frame(Y=Y), 
                X = data.frame(X1=X1, X2=X2),
                test="asymptotic", parallel=FALSE)
mean(res_asymp_unadj$pvals$raw_pval<0.05)
hist(res_asymp_unadj$pvals$raw_pval)

res_asymp_adj <- cit_multi(M = data.frame(Y=Y), 
                X = data.frame(X1=X1, X2=X2), 
                Z = data.frame(Z1=Z1, Z2=Z2),
                test="asymptotic", parallel=FALSE)
mean(res_asymp_adj$pvals$raw_pval<0.05)
hist(res_asymp_adj$pvals$raw_pval)

if(interactive()){
res_perm_unadj <- cit_multi(M = data.frame(Y=Y), 
                X = data.frame(X1=X1),
                test="permutation", parallel=TRUE)
mean(res_perm_unadj$pvals$raw_pval<0.05)

res_perm_adj <- cit_multi(M = data.frame(Y=Y), 
                X = data.frame(X1=X1), 
                Z = data.frame(Z2=Z2),
                test="permutation", 
                parallel=TRUE, 
                n_perm=100)
mean(res_perm_adj$pvals$raw_pval<0.05)
}
}
\references{
Gauthier M, Agniel D, ThiÃ©baut R & Hejblum BP (2019).
Distribution-free complex hypothesis testing for single-cell RNA-seq differential expression analysis, *bioRxiv* 445165.
[DOI: 10.1101/2021.05.21.445165](https://doi.org/10.1101/2021.05.21.445165).
}
